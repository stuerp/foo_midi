
/** $VER: FSPlayer.cpp (2025.07.12) P. Stuer **/

#include "pch.h"

#include "FSPlayer.h"

#include "Support.h"
#include "Log.h"

static void Logger(int level, const char * message, void * data);

FSPlayer::FSPlayer() : player_t(), _Settings()
{
    ::memset(_Synths, 0, sizeof(_Synths));

    _DoDynamicLoading = false;
    _DoReverbAndChorusProcessing = true;
    _VoiceCount = 256;

    _InterpolationMethod = FLUID_INTERP_DEFAULT;
}

FSPlayer::~FSPlayer()
{
    Shutdown();
}

/// <summary>
/// Initialize the engine. (FluidSynth specific)
/// </summary>
void FSPlayer::Initialize(const WCHAR * basePath)
{
    _API.Initialize(basePath);
}

/// <summary>
/// Sets the synthesis interpolation mode.
/// </summary>
void FSPlayer::SetInterpolationMode(uint32_t method)
{
    if (_InterpolationMethod == method)
        return;

    _InterpolationMethod = method;
}

/// <summary>
/// Sets the number of voices to use.
/// </summary>
void FSPlayer::SetVoiceCount(uint32_t voiceCount)
{
    if (_VoiceCount == voiceCount)
        return;

    _VoiceCount = voiceCount;
}

/// <summary>
/// Enables or disables reverb and chorus processing.
/// </summary>
void FSPlayer::EnableEffects(bool enabled)
{
    if (_DoReverbAndChorusProcessing == enabled)
        return;

    _DoReverbAndChorusProcessing = enabled;
}

/// <summary>
/// Enables or disables dynamic loading of the sound fonts.
/// </summary>
void FSPlayer::EnableDynamicLoading(bool enabled)
{
    if (_DoDynamicLoading == enabled)
        return;

    _DoDynamicLoading = enabled;

    Shutdown();
}

/// <summary>
/// Sets the sound fonts to use for synthesis.
/// </summary>
void FSPlayer::SetSoundFonts(const std::vector<soundfont_t> & soundFonts)
{
    if (_SoundFonts == soundFonts)
        return;

    _SoundFonts = soundFonts;

    Shutdown();
}

/// <summary>
/// Gets the numbers of voices that are currently active.
/// </summary>
uint32_t FSPlayer::GetActiveVoiceCount() const noexcept
{
    uint32_t VoiceCount = 0;

    for (const auto & Synth : _Synths)
    {
        if (Synth != nullptr)
            VoiceCount += _API.GetActiveVoiceCount(Synth);
    }

    return VoiceCount;
}

#pragma region player_t

struct context_t
{
    FluidSynth::API * _FluidSynth;
    fluid_settings_t * _Settings;
};

bool FSPlayer::Startup()
{
    if (_IsStarted)
        return true;

    if (!_API.IsInitialized())
        return false;

    if (IsStarted())
        return true;

    _Settings = _API.CreateSettings();

    if (_Settings == nullptr)
        return false;

    {
        _API.SetIntegerSetting(_Settings, "synth.midi-channels", 32);

        // The sample rate of the audio generated by the synthesizer.
        _API.SetNumericSetting(_Settings, "synth.sample-rate", (double) _SampleRate);

        // Gain applied to the final output of the synthesizer.
        _API.SetNumericSetting(_Settings, "synth.gain", 0.8);

        // Device identifier used for SYSEX commands, such as MIDI Tuning Standard commands.
        // Fluidsynth will only process those SYSEX commands destined for this ID (except when this setting is set to 127, which causes fluidsynth to process all SYSEX commands, regardless of the device ID).
//      _API.SetIntegerSetting(Setting, "synth.device-id", (int) (0x10 + i));

        // Load and unload samples from memory whenever presets are being selected or unselected for a MIDI channel. Supported when using FluidSynth 2.4.4 or later. Earlier versions generate a clicking sound when using incorrectly padded samples. (see https://github.com/FluidSynth/fluidsynth/issues/1484)
        if (GetVersion() >= MakeDWORD(2, 4, 4, 0))
            _API.SetIntegerSetting(_Settings, "synth.dynamic-sample-loading", _DoDynamicLoading ? 1 : 0); // Causes clicking in the cymbals of "ran.rmi".

        // When set to 1 (TRUE) the reverb effects module is activated. Otherwise, no reverb will be added to the output signal. Note that the amount of signal sent to the reverb module depends on the "reverb send" generator defined in the SoundFont.
        _API.SetIntegerSetting(_Settings, "synth.reverb.active", _DoReverbAndChorusProcessing ? 1 : 0);
        // Sets the amount of reverb damping. (0.0 - 1.0, Default: 0.3)
        _API.SetNumericSetting(_Settings, "synth.reverb.damp", 0.3);
        // Sets the reverb output amplitude. (0.0 -   1.0, Default: 0.7)
        _API.SetNumericSetting(_Settings, "synth.reverb.level", 0.7);
        // Sets the room size (i.e. amount of wet) reverb. (0.0 - 1.0, Default: 0.5)
        _API.SetNumericSetting(_Settings, "synth.reverb.room-size", 0.5);
        // Sets the stereo spread of the reverb signal. (0.0 - 100.0, Default: 0.8)
        _API.SetNumericSetting(_Settings, "synth.reverb.width", 0.8);

        // When set to 1 (TRUE) the chorus effects module is activated. Otherwise, no chorus will be added to the output signal. Note that the amount of signal sent to the chorus module depends on the "chorus send" generator defined in the SoundFont.
        _API.SetIntegerSetting(_Settings, "synth.chorus.active", _DoReverbAndChorusProcessing ? 1 : 0);
        // Specifies the modulation depth of the chorus. Max. value depends on synth sample-rate. 0.0 - 21.0 is safe for sample-rate values up to 96KHz.
        _API.SetNumericSetting(_Settings, "synth.chorus.depth", 4.25);
        // Specifies the output amplitude of the chorus signal. (0.0 - 10.0)
        _API.SetNumericSetting(_Settings, "synth.chorus.level", 0.6);
        // Sets the voice count of the chorus. (0 - 99, CPU time consumption proportional to this value.)
        _API.SetIntegerSetting(_Settings, "synth.chorus.nr", 3);
        // Sets the modulation speed in Hz. (0.1 - 5.0 Hz)
        _API.SetNumericSetting(_Settings, "synth.chorus.speed", 0.2);

        // Defines how many voices can be played in parallel.
        _API.SetIntegerSetting(_Settings, "synth.polyphony", (int) _VoiceCount);

        // Defines how the synthesizer interprets Bank Select messages.
        _API.SetStringSetting(_Settings, "synth.midi-bank-select", "mma");
    }

    FluidSynth::Host Host;

    Host.LoadConfig(_API, pfc::string(CfgFluidSynthConfigFilePath).c_str(), _Settings);

    double ActualSampleRate = 0.;

    if (_API.GetNumericSetting(_Settings, "synth.sample-rate", &ActualSampleRate) == FLUID_OK)
        SetSampleRate((uint32_t) ActualSampleRate);

//  _API.SetNumericSetting(_Settings, "synth.sample-rate", (double) _SampleRate);

    // Create the syntheiszers.
    for (size_t i = 0; i < _countof(_Synths); ++i)
    {
        // Create the synthesizer.
        {
            fluid_sfloader_t * Loader = GetSoundFontLoader(_Settings);

            if (Loader == nullptr)
            {
                _ErrorMessage = "Failed to create SoundFont loader";

                return false;
            }

            _Synths[i] = _API.CreateSynthesizer(_Settings);

            if (_Synths[i] == nullptr)
            {
                _ErrorMessage = "Failed to create synthesizer";

                return false;
            }

            _API.AddSoundFontLoader(_Synths[i], Loader);

            _API.SetInterpolationMethod(_Synths[i], -1, (int) _InterpolationMethod);

            _API.SetChorusType(_Synths[i], fluid_chorus_mod::FLUID_CHORUS_MOD_SINE);

            for (const auto & sf : _SoundFonts)
            {
                if (!_API.IsSoundFont(sf.FilePath().c_str()))
                    continue;

                int SoundFontId = _API.LoadSoundFont(_Synths[i], sf.FilePath().c_str(), TRUE);

                if (SoundFontId == FLUID_FAILED)
                {
                    Shutdown();

                    _ErrorMessage = "Failed to load SoundFont \"" + sf.FilePath() + "\"";

                    return false;
                }

                int BankOffset = sf.BankOffset();

                _API.SetSoundFontBankOffset(_Synths[i], SoundFontId, BankOffset);
            }
        }
    }

    _API.SetLogFunction(FLUID_PANIC, Logger, nullptr);
    _API.SetLogFunction(FLUID_ERR, Logger, nullptr);
    _API.SetLogFunction(FLUID_WARN, Logger, nullptr);
    _API.SetLogFunction(FLUID_DBG,Logger, nullptr);

    _ErrorMessage = "";

    _IsStarted = true;

    {
        const DWORD Version = GetVersion();

        Log.AtInfo().Format(STR_COMPONENT_BASENAME " is using FluidSynth %d.%d.%d.", (Version >> 24) & 0xFF, (Version >> 16) & 0xFF, (Version >> 8) & 0xFF);
    }

    Configure(_MIDIFlavor, _FilterEffects);
    Reset();

    return true;
}

void FSPlayer::Shutdown()
{
    for (auto & Synth : _Synths)
    {
        if (Synth != nullptr)
        {
            _API.DeleteSynthesizer(Synth);
            Synth = nullptr;
        }
    }

    if (_Settings != nullptr)
    {
        _API.DeleteSettings(_Settings);
        _Settings = nullptr;
    }

    _IsStarted = false;
}

void FSPlayer::Render(audio_sample * dstFrames, uint32_t dstCount)
{
    static const uint32_t MaxFrames = 512;
    static const uint32_t MaxChannels = 2;

    ::memset(dstFrames, 0, ((size_t) dstCount * MaxChannels) * sizeof(audio_sample));

    uint32_t dstDone = 0;

    while (dstDone < dstCount)
    {
        float srcFrames[MaxFrames * MaxChannels];

        uint32_t srcCount = dstCount - dstDone;

        if (srcCount > MaxFrames)
            srcCount = MaxFrames;

        for (const auto & Synth : _Synths)
        {
            ::memset(srcFrames, 0, sizeof(srcFrames));

            _API.WriteFloat(Synth, (int) srcCount, srcFrames, 0, MaxChannels, srcFrames, 1, MaxChannels);

            // Convert the format of the rendered output.
            for (uint32_t i = 0, j = 0; i < srcCount; ++i)
            {
                dstFrames[j] += srcFrames[j];
                ++j;
                dstFrames[j] += srcFrames[j];
                ++j;
            }
        }

        dstFrames += srcCount * MaxChannels;
        dstDone += srcCount;
    }
}

/// <summary>
/// Resets the player.
/// </summary>
bool FSPlayer::Reset()
{
    size_t ResetCount = 0;

    uint8_t PortNumber = 0;

    for (const auto & Synth : _Synths)
    {
        if (Synth != nullptr)
        {
            _API.ResetSynthesizer(Synth);

            ResetPort(PortNumber, 0);

            ++ResetCount;
        }

        ++PortNumber;
    }

    return (ResetCount == _countof(_Synths));
}

/// <summary>
/// Sends a message to the library.
/// </summary>
void FSPlayer::SendEvent(uint32_t data)
{
    int PortNumber = (int) ((data >> 24) & 0x7F);
    int Param2     = (int) ((data >> 16) & 0xFF);
    int Param1     = (int) ((data >>  8) & 0xFF);
    int Code       = (int)  (data        & 0xF0);
    int Channel    = (int)  (data        & 0x0F);

    if (PortNumber >= (int) _countof(_Synths))
        PortNumber = 0;

    switch (Code)
    {
        case midi::NoteOff:
            _API.NoteOff(_Synths[PortNumber], Channel, Param1);
            break;

        case midi::NoteOn:
            _API.NoteOn(_Synths[PortNumber], Channel, Param1, Param2);
            break;

        case midi::KeyPressure:
            _API.KeyPressure(_Synths[PortNumber], Channel, Param1, Param2);
            break;

        case midi::ControlChange:
            _API.ControlChange(_Synths[PortNumber], Channel, Param1, Param2);
            break;

        case midi::ProgramChange:
            _API.ProgramChange(_Synths[PortNumber], Channel, Param1);
            break;

        case midi::ChannelPressure:
            _API.ChannelPressure(_Synths[PortNumber], Channel, Param1);
            break;

        case midi::PitchBendChange:
            _API.PitchBend(_Synths[PortNumber], Channel, (Param2 << 7) | Param1);
            break;
    }
}

/// <summary>
/// Sends a SysEx message to the library.
/// </summary>
void FSPlayer::SendSysEx(const uint8_t * data, size_t size, uint32_t portNumber)
{
    if ((data != nullptr) && (size > 2) && (data[0] == midi::SysEx) && (data[size - 1] == midi::SysExEnd))
    {
        ++data;
        size -= 2;

        if (portNumber >= _countof(_Synths))
            portNumber = 0;

        if (portNumber == 0)
        {
            for (const auto & Synth : _Synths)
                _API.SysEx(Synth, (const char *) data, (int) size, NULL, NULL, NULL, 0);
        }
        else
            _API.SysEx(_Synths[portNumber], (const char *) data, (int) size, NULL, NULL, NULL, 0);
    }
}

#pragma endregion

#pragma region Sound font loader

static void * HandleOpen(const char * filePath) noexcept
{
    try
    {
        std::string URI = "file://";

        URI += filePath;

        file::ptr * File = new file::ptr;

        filesystem::g_open(*File, URI.c_str(), filesystem::open_mode_read, fb2k::noAbort);

        return (void *) File;
    }
    catch (...)
    {
        return nullptr;
    }
}

static int HandleRead(void * data, fluid_long_long_t size, void * handle) noexcept
{
    try
    {
        file::ptr * File = (file::ptr *) handle;

        (*File)->read_object(data, (t_size) size, fb2k::noAbort);

        return FLUID_OK;
    }
    catch (...)
    {
        return FLUID_FAILED;
    }
}

static int HandleSeek(void * handle, fluid_long_long_t offset, int origin) noexcept
{
    try
    {
        file::ptr * File = (file::ptr *) handle;

        (*File)->seek_ex(offset, (file::t_seek_mode) origin, fb2k::noAbort);

        return FLUID_OK;
    }
    catch (...)
    {
        return FLUID_FAILED;
    }
}

static fluid_long_long_t HandleTell(void * handle) noexcept
{
    try
    {
        file::ptr * File = (file::ptr *) handle;

        return (fluid_long_long_t) (*File)->get_position(fb2k::noAbort);
    }
    catch (...)
    {
        return FLUID_FAILED;
    }
}

static int HandleClose(void * handle) noexcept
{
    try
    {
        file::ptr * File = (file::ptr *) handle;

        delete File;

        return FLUID_OK;
    }
    catch (...)
    {
        return FLUID_FAILED;
    }
}

fluid_sfloader_t * FSPlayer::GetSoundFontLoader(fluid_settings_t * settings) const
{
    fluid_sfloader_t * Loader = _API.CreateSoundFontLoader(settings);

    if (Loader == nullptr)
        return nullptr;

    if (_API.SetSoundFontLoaderCallbacks(Loader, HandleOpen, HandleRead, HandleSeek, HandleTell, HandleClose) != FLUID_OK)
        return nullptr;

    return Loader;
}

#pragma endregion

static void Logger(int level, const char * message, void * data)
{
    switch (level)
    {
        case FLUID_PANIC: Log.AtFatal().Format(STR_COMPONENT_BASENAME " FluidSynth says %s", message); break;
        case FLUID_ERR:   Log.AtError().Format(STR_COMPONENT_BASENAME " FluidSynth says %s", message); break;
        case FLUID_WARN:  Log.AtWarn() .Format(STR_COMPONENT_BASENAME " FluidSynth says %s", message); break;
        case FLUID_INFO:  Log.AtInfo() .Format(STR_COMPONENT_BASENAME " FluidSynth says %s", message); break;
        case FLUID_DBG:   Log.AtDebug().Format(STR_COMPONENT_BASENAME " FluidSynth says %s", message); break;
    }
}

#ifdef LATER
static void Callback(void * data, const char * name, int type)
{
    switch (type)
    {
/*
        case FLUID_NUM_TYPE:
        {
            double value;
            fluid_settings_getnum(d->settings, name, &value);
            fluid_ostream_printf(d->out, "%.3f\n", value);
            break;
        }

        case FLUID_INT_TYPE:
        {
            int value, hints;
            fluid_settings_getint(d->settings, name, &value);

            if(fluid_settings_get_hints(d->settings, name, &hints) == FLUID_OK)
            {
                if(!(hints & FLUID_HINT_TOGGLED))
                {
                    fluid_ostream_printf(d->out, "%d\n", value);
                }
                else
                {
                    fluid_ostream_printf(d->out, "%s\n", value ? "True" : "False");
                }
            }

            break;
        }
*/
        case FLUID_STR_TYPE:
        {
            auto Context = (context_t *) data;

            char * Value = nullptr;

            Context->_FluidSynth->GetStringSetting(Context->_Settings, name, &Value);

            console::printf("%s: %s", name, Value);

            Context->_FluidSynth->Free(Value);
            break;
        }
    }
};
#endif
